#!/usr/bin/python3
#+
# This script copies a bunch of MySQL records according to specified criteria.
# Invoke this script as follows:
#
#     bulk_copy [--user=username] [--password=password]
#          [--host=host] [--port=port] [--database=database]
#         src_table_name field_names condition dst_table_name [replace_field_value ...]
#
# where the username, password, host, port and database are used as MySQL connection parameters.
# If --password is specified but an empty value is given, then the user will be prompted for
# the password without echoing.
#
# The arguments are as follows:
#
#     src_table_name      -- the name of the table to select records from.
#     field_names         -- comma-separated list of fields to extract, or "*" for all fields.
#     condition           -- substituted as is in a MySQL where-clause to select the records.
#     dst_table_name      -- the name of the table into which to insert the records.
#     replace_field_value -- optional additional field specifications in the form "name=value"
#                            to define for the newly-inserted records.
#
# For example:
#
#     bulk_copy --database=billing jobs description,rate client_id=4 jobs client_id=8
#
# will find all entries in the "jobs" table in the "billing" database where client_id = 4
# and insert new copies with the same "description" and "rate" fields, but with client_id
# set to 8.
#
# Copyright 2009, 2015 by Lawrence D’Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import mysql.connector
import getopt
import getpass

#+
# Useful MySQL stuff
#-

def sql_iter(conn, cmd, values = None, mapfn = lambda x : x) :
    """generator which executes cmd with values in a new cursor on conn,
    yielding the rows one at a time, optionally mapped through function mapfn."""
    cursor = conn.cursor()
    cursor.execute(cmd, values)
    while True :
        yield mapfn(next(cursor))
    #end while
#end sql_iter

def sql_string(s) :
    """returns a MySQL string literal which evaluates to s. Needed
    for those times when the client API's automatic quoting isn't good enough."""
    result = []
    for ch in str(s) :
        if ch == "\0" :
            ch = "\\0"
        elif ch == "\010" :
            ch = "\\b"
        elif ch == "\011" :
            ch = "\\t"
        elif ch == "\012" :
            ch = "\\n"
        elif ch == "\015" :
            ch = "\\r"
        elif ch == "\032" :
            ch = "\\z"
        elif ch == "'" or ch == "\"" or ch == "\\" :
            ch = "\\" + ch
        #end if
        result.append(ch)
    #end for
    return "\"" + "".join(result) + "\""
#end sql_string

class BulkInserter :
    """bulk insertion of lots of records into an SQL table."""

    def __init__(self, conn, table_name, field_names, ignore_duplicates) :
        """conn is the MySQL connection to use; table_name is the name of the
        table into which to insert records; field_names is the list of field names;
        and ignore_duplicates is True to ignore duplicate insertions, False to
        report an error."""
        self.sql = conn
        self.cursor = None
        self.table_name = table_name
        self.field_names = tuple(field_names)
        self.ignore_duplicates = ignore_duplicates
        self.insert_limit = 500 # could even be larger
        self.field_values = []
    #end __init__

    def add_record(self, field_values) :
        """adds another record to the table. field_values is the list of field
        values, corresponding in order to the previously-specified field_names."""
        if len(self.field_values) == self.insert_limit :
            self.done_insert()
        #end if
        if self.cursor == None :
            self.cursor = self.sql.cursor()
        #end if
        this_record = []
        if type(field_values) == dict :
            for field_name in self.field_names :
                field_value = field_values[field_name]
                if field_value != None :
                    this_record.append(sql_string(field_value))
                else :
                    this_record.append("null")
                #end if
            #end for
        else :
            for field_value in field_values :
                if field_value != None :
                    this_record.append(sql_string(field_value))
                else :
                    this_record.append("null")
                #end if
            #end for
        #end if
        self.field_values.append(this_record)
    #end add_record

    def done_insert(self) :
        """Call this after the last add_record call to make sure all insertions
        have been flushed to the table."""
        if len(self.field_values) != 0 :
            insert = "insert delayed"
            if self.ignore_duplicates :
                insert += " ignore"
            #end if
            insert += " into " + self.table_name + " (" + ", ".join(self.field_names) + ") values"
            first_insert = True
            for this_record in self.field_values :
                if first_insert :
                    first_insert = False
                else :
                    insert += ","
                #end if
                insert += " (" + ", ".join(this_record) + ")"
            #end for
            self.cursor.execute(insert)
            self.cursor.close()
            self.cursor = None
            self.field_values = []
        #end if
    #end done_insert

#end BulkInserter

#+
# Mainline
#-

(opts, args) = getopt.getopt \
  (
    sys.argv[1:],
    "",
    [
        "database=",
        "host=",
        "password=",
        "port=",
        "user=",
    ]
  )
if len(args) < 4 :
    raise getopt.GetoptError \
      (
        "need at least src_table_name, fields, condition and dst_table_name args"
      )
#end if
src_table_name = args[0]
field_names = args[1].split(",")
condition = args[2]
dst_table_name = args[3]
replace_field_names = []
replace_field_values = []
for field in args[4:] :
    field_name, value = field.split("=", 1)
    if field_name in field_names :
        raise getopt.GetoptError("can't both copy and replace field %s" % field_name)
    #end if
    replace_field_names.append(field_name)
    replace_field_values.append(value)
#end for
conn_params = {"buffered" : True} # needed to avoid “unread result found” errors
for keyword, value in opts :
    if keyword == "--database" :
        conn_params["db"] = value
    elif keyword == "--host" :
        conn_params["host"] = value
    elif keyword == "--port" :
        conn_params["port"] = int(value)
    elif keyword == "--user" :
        conn_params["user"] = value
    elif keyword == "--password" :
        conn_params["passwd"] = value
    #end if
#end for
if conn_params.get("passwd") == "" :
    conn_params["passwd"] = getpass.getpass()
#end if
conn = mysql.connector.connect(**conn_params)
if len(field_names) == 1 and field_names[0] == "*" :
    field_names = list \
      (
            set(sql_iter
              (
                conn = conn,
                cmd = "show columns from %s" % src_table_name,
                mapfn = lambda x : x[0]
              ))
        -
            set(replace_field_names)
      )
#end if
all_field_names = field_names + replace_field_names

nr_records = 0
insert = BulkInserter(conn, dst_table_name, all_field_names, False)
for \
        entry \
    in \
        sql_iter \
          (
            conn = conn,
            cmd =
                    "select %(fields)s from %(table)s where %(condition)s"
                %
                    {
                        "fields" : ", ".join(field_names),
                        "table" : src_table_name,
                        "condition" : condition,
                    }
          ) \
:
    insert.add_record(list(entry) + replace_field_values)
    nr_records += 1
#end for
insert.done_insert()
sys.stderr.write("records inserted: %s\n" % nr_records)

conn.close()
